/*
 * interp_tab.c
 *
 *  Created on: 2023年5月9日
 *      Author: t
 */

#include"interp_tab.h"
#include "algo_code_config.h"

#ifdef TYJ_TEST

// 仿真所用插值表

// MTPA情况下转矩和用D轴电流的对应关系，对应转矩为0，1，2……25
float TE_ID_MTPA_2WAY_TAB[]={
-76.4522F,
-74.1545F,
-71.8568F,
-69.5591F,
-67.2123F,
-64.8132F,
-62.3588F,
-59.8444F,
-57.2659F,
-54.6185F,
-51.8963F,
-49.0928F,
-46.2006F,
-43.2117F,
-40.1157F,
-36.9024F,
-33.5571F,
-30.0660F,
-26.4112F,
-22.5761F,
-18.5437F,
-14.3093F,
-9.9069F,
-5.5048F,
-1.6960F,
-0.0000F,
-1.6960F,
-5.5048F,
-9.9069F,
-14.3093F,
-18.5437F,
-22.5761F,
-26.4112F,
-30.0660F,
-33.5571F,
-36.9024F,
-40.1157F,
-43.2117F,
-46.2006F,
-49.0928F,
-51.8963F,
-54.6185F,
-57.2659F,
-59.8444F,
-62.3588F,
-64.8132F,
-67.2123F,
-69.5591F,
-71.8568F,
-74.1545F,
-76.4522F,
};

// MTPA情况下转矩和用Q轴电流的对应关系，对应转矩为0，1，2……25
float TE_IQ_MTPA_2WAY_TAB[]={
-98.9228F,
-96.5387F,
-94.1546F,
-91.7705F,
-89.3305F,
-86.8309F,
-84.2676F,
-81.6348F,
-78.9267F,
-76.1370F,
-73.2575F,
-70.2788F,
-67.1901F,
-63.9789F,
-60.6286F,
-57.1211F,
-53.4300F,
-49.5258F,
-45.3662F,
-40.8982F,
-36.0429F,
-30.6899F,
-24.6659F,
-17.7129F,
-9.4901F,
0.0000F,
9.4901F,
17.7129F,
24.6659F,
30.6899F,
36.0429F,
40.8982F,
45.3662F,
49.5258F,
53.4300F,
57.1211F,
60.6286F,
63.9789F,
67.1901F,
70.2788F,
73.2575F,
76.1370F,
78.9267F,
81.6348F,
84.2676F,
86.8309F,
89.3305F,
91.7705F,
94.1546F,
96.5387F,
98.9228F,
};

#else

 // Id=0情况下转矩和用两套绕组的总电流的对应关系，对应转矩为0，1，2……12
float TE_IQ_ID0_2WAY_TAB[] = {
-110.0000F, //-12
-110.0000F, //-11
-110.0000F,
-101.0000F,
-88.7500F,
-77.0000F,
-65.0000F,
-54.0000F,
-44.0000F,
-34.0000F,
-23.7500F,
-11.2500F,
0.0000F,
11.2500F,
23.7500F,
34.0000F,
44.0000F,
54.0000F,
65.0000F,
77.0000F,
88.7500F,
101.0000F,
110.0000F,
110.0000F, //11
110.0000F, //12
};

// MTPA情况下转矩和用D轴电流的对应关系，对应转矩为0，1，2……23
float TE_ID_MTPA_2WAY_TAB[] = {
-95.1993F, //-25
-90.9582F, //-24
-86.7171F, //-23
-82.4760F, //-22
-78.2349F, //-21
-73.9938F,
-69.8192F,
-65.9019F,
-62.0809F,
-58.1454F,
-54.5526F,
-50.7952F,
-47.0607F,
-43.5219F,
-40.1762F,
-36.4646F,
-32.7767F,
-29.1138F,
-25.4885F,
-21.8242F,
-18.0281F,
-14.3423F,
-10.4731F,
-6.2729F,
-2.4611F,
0.0000F,  //0
-2.4611F,
-6.2729F,
-10.4731F,
-14.3423F,
-18.0281F,
-21.8242F,
-25.4885F,
-29.1138F,
-32.7767F,
-36.4646F,
-40.1762F,
-43.5219F,
-47.0607F,
-50.7952F,
-54.5526F,
-58.1454F,
-62.0809F,
-65.9019F,
-69.8192F,
-73.9938F, //20
-78.2349F, //21
-82.4760F, //22
-86.7171F, //23
-90.9582F, //24
-95.1993F, //25
};

// MTPA情况下转矩和用Q轴电流的对应关系，对应转矩为0，1，2……23
float TE_IQ_MTPA_2WAY_TAB[] = {
-67.8156F, //-25
-66.4327F, //-24
-65.0498F, //-23
-63.6669F, //-22
-62.2840F, //-21
-60.9011F,
-59.3975F,
-57.8522F,
-56.2140F,
-54.3850F,
-52.5832F,
-50.5565F,
-48.3895F,
-46.1867F,
-44.0005F,
-41.7293F,
-39.3986F,
-37.0031F,
-34.5279F,
-31.8822F,
-28.9340F,
-25.7788F,
-22.0103F,
-17.0049F,
-10.5501F,
0.0000F,
10.5501F,
17.0049F,
22.0103F,
25.7788F,
28.9340F,
31.8822F,
34.5279F,
37.0031F,
39.3986F,
41.7293F,
44.0005F,
46.1867F,
48.3895F,
50.5565F,
52.5832F,
54.3850F,
56.2140F,
57.8522F,
59.3975F,
60.9011F,
62.2840F, //21
63.6669F, //22
65.0498F, //23
66.4327F, //24
67.8156F, //25
};

#endif

#if 0

#pragma CODE_SECTION(lookUp_1d_lin, MEM_MACRO);
float lookUp_1d_lin(float xIn, const float xTab[], const float yTab[], int16_t* hPrevIndex, int16_t maxIndex)
{
    float frac;
    float yAns;
    float yLeft;
    int16_t tabIdx;
    int16_t isFound;
    int16_t idxLeft;
    int16_t idxRight;

    if (xIn <= xTab[0])
    {
        tabIdx = 0;
        frac = 0.0F;
    }
    else if (xIn < xTab[maxIndex])
    {
        tabIdx = *hPrevIndex;
        idxLeft = 0;
        idxRight = maxIndex;
        isFound = 0;
        while (isFound == 0)
        {
            if (xIn < xTab[tabIdx])
            {
                idxRight = tabIdx - 1;
                tabIdx = ((tabIdx + idxLeft) - 1) >> 1;
            }
            else if (xIn < xTab[tabIdx + 1])
            {
                isFound = 1;
            }
            else
            {
                idxLeft = tabIdx + 1;
                tabIdx = ((tabIdx + idxRight) + 1) >> 1;
            }
        }

        frac = (xIn - xTab[tabIdx]) / (xTab[tabIdx + 1] - xTab[tabIdx]);
    }
    else
    {
        tabIdx = maxIndex;
        frac = 0.0F;
    }

    *hPrevIndex = tabIdx;

    if (tabIdx == maxIndex)
    {
        yAns = yTab[tabIdx];
    }
    else
    {
        yLeft = yTab[tabIdx];
        yAns = (yTab[tabIdx + 1] - yLeft) * frac + yLeft;
    }

    return yAns;
}

#endif
